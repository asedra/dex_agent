import sys
import os
import json
import tempfile

# Embedded configuration
CONFIG_DATA = {
  "server_url": "ws://localhost:8080",
  "api_token": "test-token",
  "agent_name": "FrontendEXE",
  "tags": [
    "frontend-test"
  ],
  "auto_start": true,
  "run_as_service": false
}

def create_temp_config():
    """Create temporary config file"""
    temp_dir = tempfile.gettempdir()
    config_path = os.path.join(temp_dir, "dexagent_config.json")
    with open(config_path, 'w') as f:
        json.dump(CONFIG_DATA, f, indent=2)
    return config_path

def main():
    try:
        # Check if required modules are available
        try:
            import websockets
            import asyncio
            import tkinter as tk
            import psutil
            import requests
        except ImportError as e:
            import tkinter.messagebox as msgbox
            msgbox.showerror("Missing Dependencies", 
                f"Required Python modules are missing: {e}\n\n"
                "Please install Python with the following packages:\n"
                "pip install websockets psutil requests\n\n"
                "Or download and run the Windows installer from our website.")
            return
        
        # Create temporary config
        config_path = create_temp_config()
        
        # Import and run the agent
        sys.path.insert(0, os.path.dirname(__file__))
        
        # Create agent instance with embedded config
        import asyncio
        import json
        
import asyncio
import websockets
import json
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import threading
import time
import requests
import psutil
import platform
import socket
import subprocess
import logging
from datetime import datetime
import uuid

class EmbeddedDexAgent:
    def __init__(self):
        self.config = CONFIG_DATA
        self.running = False
        self.websocket = None
        self.root = None
        self.setup_gui()
        
    def setup_gui(self):
        self.root = tk.Tk()
        self.root.title(f"DexAgent - {self.config.get('agent_name', 'Windows')}")
        self.root.geometry("500x400")
        
        # Status frame
        status_frame = ttk.Frame(self.root)
        status_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(status_frame, text="Status:").pack(side=tk.LEFT)
        self.status_label = ttk.Label(status_frame, text="Disconnected", foreground="red")
        self.status_label.pack(side=tk.LEFT, padx=10)
        
        # Connect button
        self.connect_button = ttk.Button(status_frame, text="Connect", command=self.toggle_connection)
        self.connect_button.pack(side=tk.RIGHT)
        
        # Log area
        ttk.Label(self.root, text="Activity Log:").pack(anchor=tk.W, padx=10)
        self.log_text = scrolledtext.ScrolledText(self.root, height=20, width=60)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Server info
        info_frame = ttk.Frame(self.root)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        ttk.Label(info_frame, text=f"Server: {self.config.get('server_url', 'N/A')}").pack(side=tk.LEFT)
        
    def log(self, message):
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        self.log_text.insert(tk.END, log_message)
        self.log_text.see(tk.END)
        
    def toggle_connection(self):
        if self.running:
            self.disconnect()
        else:
            self.connect()
            
    def connect(self):
        if not self.running:
            self.running = True
            self.status_label.config(text="Connecting...", foreground="orange")
            self.connect_button.config(text="Disconnect")
            thread = threading.Thread(target=self.websocket_worker, daemon=True)
            thread.start()
            
    def disconnect(self):
        self.running = False
        self.status_label.config(text="Disconnected", foreground="red")
        self.connect_button.config(text="Connect")
        self.log("Disconnected from server")
        
    def websocket_worker(self):
        asyncio.run(self.websocket_handler())
        
    async def websocket_handler(self):
        server_url = self.config.get('server_url', '').replace('http://', 'ws://').replace('https://', 'wss://')
        if not server_url.endswith('/ws'):
            server_url = server_url.rstrip('/') + '/api/v1/ws'
            
        try:
            async with websockets.connect(server_url) as websocket:
                self.websocket = websocket
                self.root.after(0, lambda: self.status_label.config(text="Connected", foreground="green"))
                self.root.after(0, lambda: self.log("Connected to server"))
                
                # Send registration
                registration = {
                    "type": "register",
                    "agent_id": str(uuid.uuid4()),
                    "agent_name": self.config.get('agent_name', 'Windows'),
                    "tags": self.config.get('tags', []),
                    "system_info": self.get_system_info()
                }
                await websocket.send(json.dumps(registration))
                
                # Listen for messages
                async for message in websocket:
                    if not self.running:
                        break
                    data = json.loads(message)
                    await self.handle_message(data)
                    
        except Exception as e:
            self.root.after(0, lambda: self.log(f"Connection error: {str(e)}"))
            self.root.after(0, self.disconnect)
            
    async def handle_message(self, data):
        if data.get('type') == 'command':
            self.root.after(0, lambda: self.log(f"Executing: {data.get('command', '')}"))
            result = await self.execute_command(data.get('command', ''))
            
            response = {
                "type": "command_result",
                "command_id": data.get('command_id'),
                "result": result
            }
            
            if self.websocket:
                await self.websocket.send(json.dumps(response))
                
    async def execute_command(self, command):
        try:
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            stdout, stderr = await process.communicate()
            
            result = {
                "stdout": stdout.decode('utf-8', errors='ignore'),
                "stderr": stderr.decode('utf-8', errors='ignore'),
                "return_code": process.returncode
            }
            
            self.root.after(0, lambda: self.log(f"Command completed (exit code: {process.returncode})"))
            return result
            
        except Exception as e:
            error_result = {
                "stdout": "",
                "stderr": str(e),
                "return_code": -1
            }
            self.root.after(0, lambda: self.log(f"Command failed: {str(e)}"))
            return error_result
            
    def get_system_info(self):
        try:
            cpu_usage = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            return {
                "cpu_usage": cpu_usage,
                "memory_usage": memory.percent,
                "disk_usage": disk.percent,
                "platform": platform.system(),
                "hostname": socket.gethostname()
            }
        except Exception as e:
            return {"error": str(e)}
            
    def run(self):
        if self.config.get('auto_start', False):
            self.root.after(1000, self.connect)
        self.root.mainloop()

async def start_agent():
    agent = EmbeddedDexAgent()
    agent.run()

        
        # Start the agent
        asyncio.run(start_agent())
        
    except Exception as e:
        import tkinter.messagebox as msgbox
        msgbox.showerror("Agent Error", f"Failed to start agent: {str(e)}")

if __name__ == "__main__":
    main()
