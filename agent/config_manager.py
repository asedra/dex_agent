#!/usr/bin/env python3
"""
DexAgents Configuration Manager
Secure configuration handling with encryption and validation
"""

import json
import os
import platform
import socket
from datetime import datetime
from typing import Dict, Any, Optional
import base64
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class ConfigManager:
    def __init__(self, config_file: str = "config.json"):
        self.config_file = config_file
        self.config_dir = os.path.dirname(os.path.abspath(config_file))
        self.backup_dir = os.path.join(self.config_dir, "config_backups")
        
        # Encryption settings
        self.use_encryption = True
        self.key_file = os.path.join(self.config_dir, ".config_key")
        self._encryption_key = None
        
        # Configuration schema for validation
        self.config_schema = {
            'server_url': {'type': str, 'required': True},
            'api_token': {'type': str, 'required': True, 'encrypted': True},
            'agent_name': {'type': str, 'required': True},
            'tags': {'type': list, 'required': False, 'default': []},
            'auto_start': {'type': bool, 'required': False, 'default': False},
            'minimize_to_tray': {'type': bool, 'required': False, 'default': True},
            'run_as_service': {'type': bool, 'required': False, 'default': False},
            'log_level': {'type': str, 'required': False, 'default': 'INFO'},
            'connection_timeout': {'type': int, 'required': False, 'default': 10},
            'reconnection_attempts': {'type': int, 'required': False, 'default': 10},
            'heartbeat_interval': {'type': int, 'required': False, 'default': 30},
            'command_timeout': {'type': int, 'required': False, 'default': 30},
            'max_log_size_mb': {'type': int, 'required': False, 'default': 10},
            'max_log_files': {'type': int, 'required': False, 'default': 5},
            'enable_system_monitoring': {'type': bool, 'required': False, 'default': True},
            'monitoring_interval': {'type': int, 'required': False, 'default': 5},
            'proxy_settings': {'type': dict, 'required': False, 'default': {}},\n            'ssl_verify': {'type': bool, 'required': False, 'default': True},\n            'custom_ca_bundle': {'type': str, 'required': False, 'default': ''},\n            'debug_mode': {'type': bool, 'required': False, 'default': False}\n        }\n        \n        # Import logger\n        from logger import Logger\n        self.logger = Logger()\n        \n        # Ensure directories exist\n        os.makedirs(self.config_dir, exist_ok=True)\n        os.makedirs(self.backup_dir, exist_ok=True)\n        \n        self.logger.info(f\"Configuration manager initialized: {self.config_file}\")\n    \n    def _get_encryption_key(self) -> bytes:\n        \"\"\"Get or create encryption key\"\"\"\n        if self._encryption_key:\n            return self._encryption_key\n        \n        if os.path.exists(self.key_file):\n            # Load existing key\n            try:\n                with open(self.key_file, 'rb') as f:\n                    self._encryption_key = f.read()\n                return self._encryption_key\n            except Exception as e:\n                self.logger.warning(f\"Failed to load encryption key: {e}\")\n        \n        # Generate new key\n        try:\n            # Use machine-specific data for key derivation\n            machine_data = f\"{platform.node()}-{platform.machine()}-{platform.processor()}\".encode()\n            \n            # Add current user info if available\n            try:\n                import getpass\n                machine_data += getpass.getuser().encode()\n            except Exception:\n                pass\n            \n            # Derive key from machine data\n            kdf = PBKDF2HMAC(\n                algorithm=hashes.SHA256(),\n                length=32,\n                salt=b'dexagents_salt_2024',  # Fixed salt for reproducibility\n                iterations=100000,\n            )\n            \n            key = base64.urlsafe_b64encode(kdf.derive(machine_data))\n            \n            # Save key to file with restricted permissions\n            with open(self.key_file, 'wb') as f:\n                f.write(key)\n            \n            # Set restrictive permissions (owner only)\n            if os.name != 'nt':  # Unix-like systems\n                os.chmod(self.key_file, 0o600)\n            \n            self._encryption_key = key\n            self.logger.info(\"Generated new encryption key\")\n            \n            return self._encryption_key\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to generate encryption key: {e}\")\n            self.use_encryption = False\n            return b''\n    \n    def _encrypt_value(self, value: str) -> str:\n        \"\"\"Encrypt a configuration value\"\"\"\n        if not self.use_encryption or not value:\n            return value\n        \n        try:\n            key = self._get_encryption_key()\n            if not key:\n                return value\n            \n            f = Fernet(key)\n            encrypted = f.encrypt(value.encode())\n            return base64.urlsafe_b64encode(encrypted).decode()\n            \n        except Exception as e:\n            self.logger.error(f\"Encryption failed: {e}\")\n            return value\n    \n    def _decrypt_value(self, encrypted_value: str) -> str:\n        \"\"\"Decrypt a configuration value\"\"\"\n        if not self.use_encryption or not encrypted_value:\n            return encrypted_value\n        \n        try:\n            key = self._get_encryption_key()\n            if not key:\n                return encrypted_value\n            \n            f = Fernet(key)\n            encrypted_bytes = base64.urlsafe_b64decode(encrypted_value.encode())\n            decrypted = f.decrypt(encrypted_bytes)\n            return decrypted.decode()\n            \n        except Exception as e:\n            self.logger.debug(f\"Decryption failed, value may not be encrypted: {e}\")\n            return encrypted_value\n    \n    def get_default_config(self) -> Dict[str, Any]:\n        \"\"\"Get default configuration\"\"\"\n        hostname = socket.gethostname()\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        \n        default_config = {\n            'server_url': 'ws://localhost:8080',\n            'api_token': 'your-api-token-here',\n            'agent_name': f'WindowsAgent_{hostname}_{timestamp}',\n            'tags': ['windows', 'powershell', 'agent'],\n            'auto_start': False,\n            'minimize_to_tray': True,\n            'run_as_service': False,\n            'log_level': 'INFO',\n            'connection_timeout': 10,\n            'reconnection_attempts': 10,\n            'heartbeat_interval': 30,\n            'command_timeout': 30,\n            'max_log_size_mb': 10,\n            'max_log_files': 5,\n            'enable_system_monitoring': True,\n            'monitoring_interval': 5,\n            'proxy_settings': {},\n            'ssl_verify': True,\n            'custom_ca_bundle': '',\n            'debug_mode': False\n        }\n        \n        return default_config\n    \n    def validate_config(self, config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate and normalize configuration\"\"\"\n        validated_config = {}\n        errors = []\n        \n        for key, schema in self.config_schema.items():\n            value = config.get(key)\n            \n            # Check required fields\n            if schema.get('required', False) and value is None:\n                if 'default' in schema:\n                    value = schema['default']\n                else:\n                    errors.append(f\"Required field '{key}' is missing\")\n                    continue\n            \n            # Use default if not provided\n            if value is None and 'default' in schema:\n                value = schema['default']\n            \n            # Type validation\n            if value is not None:\n                expected_type = schema['type']\n                if not isinstance(value, expected_type):\n                    try:\n                        # Try to convert\n                        if expected_type == bool and isinstance(value, str):\n                            value = value.lower() in ('true', '1', 'yes', 'on')\n                        elif expected_type == int and isinstance(value, str):\n                            value = int(value)\n                        elif expected_type == str and not isinstance(value, str):\n                            value = str(value)\n                        else:\n                            raise ValueError(f\"Cannot convert {type(value)} to {expected_type}\")\n                    except (ValueError, TypeError):\n                        errors.append(f\"Field '{key}' must be of type {expected_type.__name__}\")\n                        continue\n            \n            validated_config[key] = value\n        \n        # Additional validation\n        self._validate_special_fields(validated_config, errors)\n        \n        if errors:\n            raise ValueError(f\"Configuration validation failed: {'; '.join(errors)}\")\n        \n        return validated_config\n    \n    def _validate_special_fields(self, config: Dict[str, Any], errors: List[str]):\n        \"\"\"Validate special configuration fields\"\"\"\n        # Validate server URL\n        server_url = config.get('server_url', '')\n        if server_url and not (server_url.startswith('ws://') or server_url.startswith('wss://') or \n                              server_url.startswith('http://') or server_url.startswith('https://')):\n            errors.append(\"server_url must start with ws://, wss://, http://, or https://\")\n        \n        # Validate agent name\n        agent_name = config.get('agent_name', '')\n        if agent_name and (len(agent_name) < 3 or len(agent_name) > 64):\n            errors.append(\"agent_name must be between 3 and 64 characters\")\n        \n        # Validate timeouts\n        for field in ['connection_timeout', 'command_timeout', 'heartbeat_interval']:\n            value = config.get(field, 0)\n            if value and (value < 1 or value > 3600):\n                errors.append(f\"{field} must be between 1 and 3600 seconds\")\n        \n        # Validate log settings\n        max_log_size = config.get('max_log_size_mb', 0)\n        if max_log_size and (max_log_size < 1 or max_log_size > 100):\n            errors.append(\"max_log_size_mb must be between 1 and 100\")\n        \n        max_log_files = config.get('max_log_files', 0)\n        if max_log_files and (max_log_files < 1 or max_log_files > 20):\n            errors.append(\"max_log_files must be between 1 and 20\")\n        \n        # Validate log level\n        log_level = config.get('log_level', '')\n        if log_level and log_level not in ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']:\n            errors.append(\"log_level must be DEBUG, INFO, WARNING, ERROR, or CRITICAL\")\n    \n    def load_config(self, config_file: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Load configuration from file\"\"\"\n        if config_file:\n            config_path = config_file\n        else:\n            config_path = self.config_file\n        \n        # Start with default configuration\n        config = self.get_default_config()\n        \n        if os.path.exists(config_path):\n            try:\n                with open(config_path, 'r', encoding='utf-8') as f:\n                    loaded_config = json.load(f)\n                \n                # Decrypt encrypted fields\n                for key, value in loaded_config.items():\n                    if (key in self.config_schema and \n                        self.config_schema[key].get('encrypted', False) and \n                        isinstance(value, str)):\n                        loaded_config[key] = self._decrypt_value(value)\n                \n                # Merge with defaults\n                config.update(loaded_config)\n                \n                self.logger.info(f\"Configuration loaded from {config_path}\")\n                \n            except json.JSONDecodeError as e:\n                self.logger.error(f\"Invalid JSON in config file: {e}\")\n                raise ValueError(f\"Configuration file contains invalid JSON: {e}\")\n            except Exception as e:\n                self.logger.error(f\"Error loading config file: {e}\")\n                raise RuntimeError(f\"Failed to load configuration: {e}\")\n        else:\n            self.logger.info(\"No config file found, using defaults\")\n        \n        # Validate configuration\n        validated_config = self.validate_config(config)\n        \n        return validated_config\n    \n    def save_config(self, config: Dict[str, Any], config_file: Optional[str] = None) -> bool:\n        \"\"\"Save configuration to file\"\"\"\n        if config_file:\n            config_path = config_file\n        else:\n            config_path = self.config_file\n        \n        try:\n            # Validate configuration before saving\n            validated_config = self.validate_config(config)\n            \n            # Create backup if file exists\n            if os.path.exists(config_path):\n                self._create_backup(config_path)\n            \n            # Encrypt sensitive fields\n            config_to_save = validated_config.copy()\n            for key, value in config_to_save.items():\n                if (key in self.config_schema and \n                    self.config_schema[key].get('encrypted', False) and \n                    isinstance(value, str)):\n                    config_to_save[key] = self._encrypt_value(value)\n            \n            # Add metadata\n            config_to_save['_metadata'] = {\n                'created_at': datetime.now().isoformat(),\n                'version': '2.0.0',\n                'hostname': socket.gethostname(),\n                'platform': platform.system()\n            }\n            \n            # Write configuration\n            with open(config_path, 'w', encoding='utf-8') as f:\n                json.dump(config_to_save, f, indent=2, ensure_ascii=False)\n            \n            # Set restrictive permissions\n            if os.name != 'nt':  # Unix-like systems\n                os.chmod(config_path, 0o600)\n            \n            self.logger.info(f\"Configuration saved to {config_path}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error saving config: {e}\")\n            return False\n    \n    def _create_backup(self, config_path: str):\n        \"\"\"Create backup of existing configuration\"\"\"\n        try:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            backup_name = f\"config_backup_{timestamp}.json\"\n            backup_path = os.path.join(self.backup_dir, backup_name)\n            \n            # Copy current config to backup\n            with open(config_path, 'r', encoding='utf-8') as src:\n                config_data = src.read()\n            \n            with open(backup_path, 'w', encoding='utf-8') as dst:\n                dst.write(config_data)\n            \n            self.logger.info(f\"Configuration backup created: {backup_path}\")\n            \n            # Clean old backups (keep only last 10)\n            self._cleanup_old_backups()\n            \n        except Exception as e:\n            self.logger.warning(f\"Failed to create config backup: {e}\")\n    \n    def _cleanup_old_backups(self):\n        \"\"\"Clean up old backup files\"\"\"\n        try:\n            backup_files = []\n            for filename in os.listdir(self.backup_dir):\n                if filename.startswith('config_backup_') and filename.endswith('.json'):\n                    backup_path = os.path.join(self.backup_dir, filename)\n                    backup_files.append((backup_path, os.path.getmtime(backup_path)))\n            \n            # Sort by modification time (newest first)\n            backup_files.sort(key=lambda x: x[1], reverse=True)\n            \n            # Remove old backups (keep only 10 most recent)\n            for backup_path, _ in backup_files[10:]:\n                try:\n                    os.remove(backup_path)\n                    self.logger.debug(f\"Removed old backup: {backup_path}\")\n                except Exception as e:\n                    self.logger.warning(f\"Failed to remove old backup {backup_path}: {e}\")\n                    \n        except Exception as e:\n            self.logger.warning(f\"Failed to cleanup old backups: {e}\")\n    \n    def get_config_info(self) -> Dict[str, Any]:\n        \"\"\"Get information about configuration\"\"\"\n        info = {\n            'config_file': self.config_file,\n            'config_exists': os.path.exists(self.config_file),\n            'backup_dir': self.backup_dir,\n            'encryption_enabled': self.use_encryption,\n            'key_file_exists': os.path.exists(self.key_file)\n        }\n        \n        if info['config_exists']:\n            try:\n                stat = os.stat(self.config_file)\n                info['file_size'] = stat.st_size\n                info['modified_time'] = datetime.fromtimestamp(stat.st_mtime).isoformat()\n            except Exception as e:\n                info['stat_error'] = str(e)\n        \n        # Count backup files\n        try:\n            backup_files = [f for f in os.listdir(self.backup_dir) \n                          if f.startswith('config_backup_') and f.endswith('.json')]\n            info['backup_count'] = len(backup_files)\n        except Exception:\n            info['backup_count'] = 0\n        \n        return info\n    \n    def restore_backup(self, backup_filename: str) -> bool:\n        \"\"\"Restore configuration from backup\"\"\"\n        backup_path = os.path.join(self.backup_dir, backup_filename)\n        \n        if not os.path.exists(backup_path):\n            self.logger.error(f\"Backup file not found: {backup_path}\")\n            return False\n        \n        try:\n            # Create backup of current config\n            if os.path.exists(self.config_file):\n                self._create_backup(self.config_file)\n            \n            # Copy backup to main config\n            with open(backup_path, 'r', encoding='utf-8') as src:\n                config_data = src.read()\n            \n            with open(self.config_file, 'w', encoding='utf-8') as dst:\n                dst.write(config_data)\n            \n            self.logger.info(f\"Configuration restored from {backup_filename}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to restore backup: {e}\")\n            return False\n    \n    def list_backups(self) -> List[Dict[str, Any]]:\n        \"\"\"List available backup files\"\"\"\n        backups = []\n        \n        try:\n            for filename in os.listdir(self.backup_dir):\n                if filename.startswith('config_backup_') and filename.endswith('.json'):\n                    backup_path = os.path.join(self.backup_dir, filename)\n                    stat = os.stat(backup_path)\n                    \n                    backups.append({\n                        'filename': filename,\n                        'size': stat.st_size,\n                        'created': datetime.fromtimestamp(stat.st_mtime).isoformat(),\n                        'path': backup_path\n                    })\n            \n            # Sort by creation time (newest first)\n            backups.sort(key=lambda x: x['created'], reverse=True)\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to list backups: {e}\")\n        \n        return backups\n\ndef main():\n    \"\"\"Test configuration manager\"\"\"\n    config_manager = ConfigManager(\"test_config.json\")\n    \n    print(\"=== Default Configuration ===\")\n    default_config = config_manager.get_default_config()\n    print(json.dumps(default_config, indent=2))\n    \n    print(\"\\n=== Saving Configuration ===\")\n    test_config = default_config.copy()\n    test_config['server_url'] = 'ws://example.com:8080'\n    test_config['api_token'] = 'secret-token-123'\n    \n    success = config_manager.save_config(test_config)\n    print(f\"Save successful: {success}\")\n    \n    print(\"\\n=== Loading Configuration ===\")\n    loaded_config = config_manager.load_config()\n    print(f\"API Token (decrypted): {loaded_config['api_token']}\")\n    \n    print(\"\\n=== Configuration Info ===\")\n    info = config_manager.get_config_info()\n    print(json.dumps(info, indent=2))\n    \n    # Clean up test file\n    try:\n        os.remove(\"test_config.json\")\n    except Exception:\n        pass\n\nif __name__ == \"__main__\":\n    main()"}